mvn clean install
mvn spring-boot:run

src/main/java/com/example/demo
├── controller
│   └── ResourceController.java
├── exception
│   ├── GlobalExceptionHandler.java
│   └── ResourceNotFoundException.java
├── model
│   └── Resource.java
├── repository
│   └── ResourceRepository.java
├── service
│   ├── ResourceService.java
│   └── ResourceServiceImpl.java
├── DemoApplication.java

src/main/resources
└── application.properties



application.properties:
Database Configuration

    Use an in-memory H2 database for simplicity.


1) GET: http://localhost:8080/api/resources


Example Response (when there are no resources):

Status Code: 200 OK

[]


2) POST: http://localhost:8080/api/resources

{
    "name": "Resource 1"
}

send one more request with body:

{
    "name": "Resource 2"
}


3) GET: http://localhost:8080/api/resources

[
    {
        "id": 1,
        "name": "Resource 1"
    },
    {
        "id": 2,
        "name": "Resource 2"
    }
]

 
 
4) GET: http://localhost:8080/api/resources/1

An unexpected error occurred: Name for argument of type [int] not specified, and parameter name information not available via reflection. Ensure that the compiler uses the '-parameters' flag.


@GetMapping("/{id}")
    public Resource getResourceById(@PathVariable int id) {
        return resourceService.getResourceById(id);
    }
	
	
updated code to fix the above error:
 @GetMapping("/{id}")
    public Resource getResourceById(@PathVariable("id") int id) {
        return resourceService.getResourceById(id);
    }
	

	
	
5) DELETE: http://localhost:8080/api/resources/1

Resource with ID 1 deleted successfully.


6) 
Additional Notes:

    Request and Response Format:
        Input and output data are in JSON format.
        The id in responses is auto-generated by the database.
		
7)  		
GlobalExceptionHandler.java

The GlobalExceptionHandler class is a centralized exception handling component in a Spring Boot application. It is annotated with @ControllerAdvice, which allows it to handle exceptions globally across the whole application, rather than having to define exception handlers in each controller individually.  The class contains two methods, each annotated with @ExceptionHandler, which specify the type of exceptions they handle. The first method, handleResourceNotFoundException, handles exceptions of type ResourceNotFoundException. When such an exception is thrown, this method returns a ResponseEntity with the exception's message and an HTTP status of HttpStatus.NOT_FOUND:

@ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<String> handleResourceNotFoundException(ResourceNotFoundException ex) {
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
    }
	
	
The second method, handleGeneralException, is a catch-all handler for any other exceptions that are not specifically handled by other methods. It returns a ResponseEntity with a generic error message and an HTTP status of HttpStatus.INTERNAL_SERVER_ERROR:

@ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleGeneralException(Exception ex) {
        return new ResponseEntity<>("An unexpected error occurred: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
	
	
8) GET: http://localhost:8080/api/resources/error
Status: 500 Internal Server Error
An unexpected error occurred: This is a simulated server error!


Explanation of How the 500 Error is Generated

    Exception in Controller:
        The throwError method throws a NullPointerException.
    Global Exception Handler:
        The @ControllerAdvice-annotated GlobalExceptionHandler catches the NullPointerException since it is a subclass of Exception.
        The handleGeneralException method formats the response with a custom error message and returns a 500 INTERNAL SERVER ERROR status.
		
		
9) Key Takeaways:
The @ControllerAdvice mechanism ensures a clean and consistent error response is returned.


10) @ControllerAdvice is a specialized annotation in Spring that allows you to write centralized exception-handling code for your application. It is typically used to define global exception-handling logic that applies to all controllers in a Spring application. By consolidating the exception-handling logic into one place, @ControllerAdvice helps reduce code duplication and improve maintainability.


Key Features of @ControllerAdvice:

    Global Exception Handling:
        It allows handling exceptions thrown by any @Controller or @RestController.
        Exceptions can be caught and handled centrally using @ExceptionHandler methods.
		
		
How It Works

When a controller throws an exception, Spring looks for an @ExceptionHandler method to handle it. If the exception is not handled within the controller itself, Spring checks for a matching handler method in the @ControllerAdvice class.


Advantages of Using @ControllerAdvice:

    Centralized Exception Management:
        Consolidates exception-handling logic, reducing duplication across controllers.

    Improved Code Readability:
        Keeps controllers focused on business logic rather than error handling.

    Enhanced Reusability:
        Exception-handling logic can be reused across multiple controllers.

    Consistency:
        Ensures uniform error responses and behavior across the application.
		
		
The @ControllerAdvice mechanism in Spring is primarily designed to handle exceptions that bubble up to the controller layer. While exceptions in the service or repository layers are not directly intercepted by @ControllerAdvice, they can still be handled if they propagate to the controller layer and are not caught beforehand.
How @ControllerAdvice Works with Service Layer Exceptions

    Exception Propagation:
        When an exception occurs in the service or repository layer, it propagates up the call stack to the controller layer (if not caught earlier).
        If the exception reaches the controller layer, @ControllerAdvice can handle it.

    Global Handling:
        @ControllerAdvice can catch any exception (including those thrown in service or repository layers) as long as the exception reaches a controller method and isn't caught or handled elsewhere.
		
_________________________________________________________________________________
SOME ADDITIONAL PRACTICE:
		
1)  To handle exceptions for unknown IDs without using @ControllerAdvice, you can throw a custom exception in your ResourceService and catch it in your ResourceController. Here's how you can do it:

a) Create a custom exception class ResourceNotFoundException.
b) Modify the ResourceServiceImpl to throw this exception when an unknown ID is given.
c) Catch the exception in the ResourceController and return an appropriate response.

 If  @GetMapping("/{id}")
    public ResponseEntity<?> getResourceById(@PathVariable("id") int id) {
        try {
            Resource resource = resourceService.getResourceById(id);
            return new ResponseEntity<>(resource, HttpStatus.OK);
        } catch (ResourceNotFoundException ex) {
            return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
        }
    }	
	
	
2) public Resource getResourceById(int id) {
        Optional<Resource> resource = resourceRepository.findById(id);
        if (resource.isPresent()) {
            return resource.get();
        } else {
            throw new ResourceNotFoundException("Resource with ID " + id + " not found.");
        }
    }
	
// This is the same as the code above in ResourceServiceImpl.java
public Resource getResourceById(int id) {
        return resourceRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Resource with ID " + id + " not found."));
    }

_________________________________________________________________________________	
		


