
-> 

public enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY;

    public boolean isWeekend() {
        return this == SATURDAY || this == SUNDAY;
    }
}




public class Main {
    public static void main(String[] args) {
        Day today = Day.FRIDAY;

        System.out.println("Today is: " + today);

        if (today.isWeekend()) {
            System.out.println("It's the weekend! ðŸŽ‰");
        } else {
            System.out.println("It's a weekday. Keep working! ðŸ’»");
        }

        // Loop through all values
        System.out.println("\nAll Days:");
        for (Day d : Day.values()) {
            System.out.println(d + (d.isWeekend() ? " (weekend)" : " (weekday)"));
        }
    }
}

Output:
Today is: FRIDAY
It's a weekday. Keep working! ðŸ’»

All Days:
MONDAY (weekday)
TUESDAY (weekday)
WEDNESDAY (weekday)
THURSDAY (weekday)
FRIDAY (weekday)
SATURDAY (weekend)
SUNDAY (weekend)


ðŸ§  What This Shows:

    Day is an enum with 7 constants.

    It includes a method isWeekend() to demonstrate custom logic inside an enum.

    Day.values() returns all constants â€” great for iteration.
----------------------------------------------------------------------------------	
	
-> enum that associates a constant (like MON) with a custom value (like "Monday"). 



public enum Day {
    MON("Monday"),
    TUE("Tuesday"),
    WED("Wednesday"),
    THU("Thursday"),
    FRI("Friday"),
    SAT("Saturday"),
    SUN("Sunday");

    private final String fullName;

    // Constructor
    Day(String fullName) {
        this.fullName = fullName;
    }

    // Getter
    public String getFullName() {
        return fullName;
    }

    public boolean isWeekend() {
        return this == SAT || this == SUN;
    }
}




public class Main {
    public static void main(String[] args) {
        Day today = Day.MON;

        System.out.println("Today is: " + today.getFullName());

        if (today.isWeekend()) {
            System.out.println("It's the weekend! ðŸŽ‰");
        } else {
            System.out.println("It's a weekday. Keep grinding! ðŸ’¼");
        }

        System.out.println("\nAll Days:");
        for (Day d : Day.values()) {
            System.out.println(d.name() + " â†’ " + d.getFullName() + (d.isWeekend() ? " (weekend)" : " (weekday)"));
        }
    }
}

Output:

Today is: Monday
It's a weekday. Keep grinding! ðŸ’¼

All Days:
MON â†’ Monday (weekday)
TUE â†’ Tuesday (weekday)
WED â†’ Wednesday (weekday)
THU â†’ Thursday (weekday)
FRI â†’ Friday (weekday)
SAT â†’ Saturday (weekend)
SUN â†’ Sunday (weekend)


ðŸ§  Highlights:

    You use MON("Monday") and associate a custom string with each enum.

    You add a constructor and a getFullName() method to access it.

    You can still use enum features like values(), name(), and comparison.
	
______________________________________________________________________________

-> Scenario: Represent a PaymentMethod enum

Each payment method:

    Has a label (e.g., "Credit Card")

    Has a fee percentage

    Implements a different way to calculate fees



public enum PaymentMethod {
    CREDIT_CARD("Credit Card", 2.5) {
        @Override
        public double calculateFee(double amount) {
            return amount * (feePercentage / 100);
        }
    },
    PAYPAL("PayPal", 3.0) {
        @Override
        public double calculateFee(double amount) {
            return (amount * feePercentage / 100) + 0.30; // Fixed transaction fee
        }
    },
    BANK_TRANSFER("Bank Transfer", 1.0) {
        @Override
        public double calculateFee(double amount) {
            return Math.max(1.0, amount * (feePercentage / 100)); // Minimum $1 fee
        }
    };

    private final String label;
    protected final double feePercentage;

    PaymentMethod(String label, double feePercentage) {
        this.label = label;
        this.feePercentage = feePercentage;
    }

    public String getLabel() {
        return label;
    }

    public abstract double calculateFee(double amount);

    public static PaymentMethod fromLabel(String label) {
        for (PaymentMethod method : values()) {
            if (method.label.equalsIgnoreCase(label)) {
                return method;
            }
        }
        throw new IllegalArgumentException("Unknown payment method: " + label);
    }
}




public class Main {
    public static void main(String[] args) {
        double amount = 100.00;

        for (PaymentMethod method : PaymentMethod.values()) {
            double fee = method.calculateFee(amount);
            System.out.printf("%s â†’ Fee for $%.2f = $%.2f%n", method.getLabel(), amount, fee);
        }

        // Use static lookup method
        String input = "paypal";
        PaymentMethod chosen = PaymentMethod.fromLabel(input);
        System.out.println("\nChosen: " + chosen.getLabel() + ", Fee: $" + chosen.calculateFee(amount));
    }
}


Output:
Credit Card â†’ Fee for $100.00 = $2.50
PayPal â†’ Fee for $100.00 = $3.30
Bank Transfer â†’ Fee for $100.00 = $1.00

Chosen: PayPal, Fee: $3.3

Key Takeaways:

    Each constant overrides the abstract calculateFee() method differently.

    You can associate custom behavior + data with each enum constant.

    fromLabel(...) is a utility method to map strings to enums â€” useful when parsing config or user input.
	
______________________________________________________________________________
-> some refactoring on PaymentMethod.java in above code:

Since the enum constants (`CREDIT_CARD`, `PAYPAL`, `BANK_TRANSFER`) are essentially subclasses of the `PaymentMethod` enum, the `protected` modifier allows them to access the `feePercentage` field directly while still restricting access from outside the `PaymentMethod` class.

If we want to make it `private`, we would need to provide a getter method for `feePercentage` and update the overridden methods to use the getter instead.

This change ensures encapsulation by making the field `private` and accessing it through a getter, getFeePercentage()



public enum PaymentMethod {
    CREDIT_CARD("Credit Card", 2.5) {
        @Override
        public double calculateFee(double amount) {
            return amount * (getFeePercentage() / 100);
        }
    },
    PAYPAL("PayPal", 3.0) {
        @Override
        public double calculateFee(double amount) {
            return (amount * getFeePercentage() / 100) + 0.30; // Fixed transaction fee
        }
    },
    BANK_TRANSFER("Bank Transfer", 1.0) {
        @Override
        public double calculateFee(double amount) {
            return Math.max(1.0, amount * (getFeePercentage() / 100)); // Minimum $1 fee
        }
    };

    private final String label;
    private final double feePercentage;

    PaymentMethod(String label, double feePercentage) {
        this.label = label;
        this.feePercentage = feePercentage;
    }

    public String getLabel() {
        return label;
    }

    public double getFeePercentage() {
        return feePercentage;
    }

    public abstract double calculateFee(double amount);

    public static PaymentMethod fromLabel(String label) {
        for (PaymentMethod method : values()) {
            if (method.label.equalsIgnoreCase(label)) {
                return method;
            }
        }
        throw new IllegalArgumentException("Unknown payment method: " + label);
    }
}
______________________________________________________________________________


